<!DOCTYPE html>
<html>
<head>
  <title>FRA Forest Viewer</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    #map { height: 88vh; width: 100%; }
    #controls { margin: 8px; display:flex; gap:12px; align-items:center; }
    #info { font-size:13px; color:#333; }

    /* new: application marker and popup styles */
    .app-icon { display:block; line-height:0; }
    .leaflet-marker-icon.app-icon { transform: translateY(-6px); } /* slight lift */

    .app-popup { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; width:320px; }
    .app-popup .title { font-weight:700; font-size:14px; margin-bottom:6px; }
    .app-popup .badge { display:inline-block; padding:4px 8px; border-radius:12px; color:#fff; font-size:12px; margin-left:8px; vertical-align:middle; }
    .app-popup .tribal-note { background:#f7f7f7; padding:8px; border-radius:6px; margin-top:6px; font-size:13px; color:#222; }
    .app-popup textarea { width:100%; box-sizing:border-box; height:72px; padding:8px; border-radius:6px; border:1px solid #ddd; font-family:inherit; font-size:13px; resize:vertical; }
    .app-popup .buttons { display:flex; gap:8px; margin-top:8px; }
    .app-popup button { flex:1; padding:8px 10px; border-radius:6px; border:0; color:#fff; cursor:pointer; font-weight:600; }
    .app-popup .btn-approve { background:#2b8c2b; }
    .app-popup .btn-reject { background:#d9534f; }
    .app-popup .meta { margin-top:8px; font-size:12px; color:#666; }
    /* admin extras */
    #adminStats { position: absolute; left: 12px; bottom: 12px; background: rgba(255,255,255,0.95); padding:10px;border-radius:8px;border:1px solid #eee; font-size:13px }
    .rec-snippet{margin-top:8px;font-size:13px;color:#222}
    .rec-item{display:flex;align-items:center;gap:8px;margin-top:6px}
    .rec-item a{color:var(--accent-2);font-weight:700;text-decoration:none}
  </style>
</head>
<body>
  <div id="controls">
    <label for="stateSelect">Select State: </label>
    <select id="stateSelect">
      <option value="">--Choose--</option>
      <option value="mp">Madhya Pradesh</option>
      <option value="odisha">Odisha</option>
      <option value="tripura">Tripura</option>
      <option value="telangana">Telangana</option>
    </select>
    <div id="info">Choose a state — valid points will be shown. Tripura has some invalid features (empty coordinates) which are ignored.</div>
    <!-- New controls: search, filters, export -->
    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <input id="searchInput" placeholder="Search applicant or village" style="padding:8px;border-radius:6px;border:1px solid #ddd;font-size:13px" />
      <select id="statusFilter" style="padding:8px;border-radius:6px;border:1px solid #ddd;font-size:13px">
        <option value="">All status</option>
        <option value="pending">Pending</option>
        <option value="approved">Approved</option>
        <option value="rejected">Rejected</option>
      </select>
      <!-- New asset filter dropdown -->
      <select id="assetFilter" style="padding:8px;border-radius:6px;border:1px solid #ddd;font-size:13px">
        <option value="all">All assets</option>
        <option value="forest">Forest</option>
        <option value="households">Households</option>
        <option value="water">Water</option>
        <option value="bareland">Bare land</option>
      </select>
      <select id="schemeFilter" style="padding:8px;border-radius:6px;border:1px solid #ddd;font-size:13px">
        <option value="">All schemes</option>
      </select>
      <input id="minScore" type="number" min="0" max="100" placeholder="min score" style="width:90px;padding:8px;border-radius:6px;border:1px solid #ddd;font-size:13px" />
      <button id="exportCsvBtn" title="Export visible applications to CSV" style="padding:8px 10px;border-radius:6px;border:0;background:#1976d2;color:#fff;font-weight:700;cursor:pointer">Export CSV</button>
    </div>
  </div>

  <div id="map"></div>
  <!-- counts area for selected marker -->
  <div id="assetCounts" style="position:absolute; right:12px; bottom:12px; background:rgba(255,255,255,0.95); padding:10px; border-radius:8px; border:1px solid #eee; font-size:13px; z-index:9999;">
    <div style="font-weight:700;margin-bottom:6px">Nearby asset counts</div>
    <div id="count_water">Water bodies: —</div>
    <div id="count_buildings">Buildings: —</div>
    <div id="count_forest">Forests: —</div>
    <div id="count_bareland">Bare land: —</div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([22.0, 82.0], 5);
    // Esri World Imagery tiles for satellite basemap (reliable coverage for India)
    const tileLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles © Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community',
      maxZoom: 18
    }).addTo(map);
    // OSM normal layer (available to toggle)
    const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap', maxZoom: 18 });

    const files = {
      "mp": "/static/geojson/mp.geojson",
      "odisha": "/static/geojson/odisha.geojson",
      "tripura": "/static/geojson/tripura.geojson",
      "telangana": "/static/geojson/telangana.geojson"
    };

    let currentLayer = null;
    let combinedLayer = null;
    const perStateData = {}; // store FeatureCollections per state
    const infoEl = document.getElementById('info');
    const stateSelect = document.getElementById('stateSelect');

    function isValidCoordinateArray(coords){
      // coords expected [lon,lat] for Points
      return Array.isArray(coords) && coords.length>=2 &&
             typeof coords[0] === 'number' && typeof coords[1] === 'number' &&
             !Number.isNaN(coords[0]) && !Number.isNaN(coords[1]);
    }

    function validFeature(feature){
      if(!feature || !feature.geometry) return false;
      const g = feature.geometry;
      if(g.type === 'Point'){
        return isValidCoordinateArray(g.coordinates);
      }
      // For other geometry types, ensure coordinates exist and not empty (basic check)
      if(g.type === 'Polygon' || g.type === 'MultiPolygon' || g.type === 'LineString' || g.type === 'MultiLineString'){
        return Array.isArray(g.coordinates) && g.coordinates.length>0;
      }
      return false;
    }

    function renderGeoJSON(data){
      if(currentLayer){
        map.removeLayer(currentLayer);
        currentLayer = null;
      }
      if(combinedLayer){
        map.removeLayer(combinedLayer);
        combinedLayer = null;
      }
      const features = (data && data.features) ? data.features.filter(validFeature) : [];
      infoEl.textContent = `Showing ${features.length} valid feature(s).`;

      if(features.length === 0){
        // nothing valid to show
        map.setView([22.0, 82.0], 5);
        return;
      }

      const fc = { type: "FeatureCollection", features: features };

      currentLayer = L.geoJSON(fc, {
        pointToLayer: function(feature, latlng){
          return L.circleMarker(latlng, { radius:4, color:'#145214', fillColor:'#2b8c2b', fillOpacity:1 });
        },
        style: function(feature){
          return { color:'#2b8c2b', weight:1, fillOpacity:0.35 };
        },
        onEachFeature: function(feature, layer){
          // show some useful popup info if present
          const props = feature.properties || {};
          let title = props.name || props.NOMENKLATUR || props['@id'] || 'Forest';
          layer.bindPopup(title);
        }
      }).addTo(map);

      // fit to bounds of the added layer; fallback center if getBounds fails
      try {
        map.fitBounds(currentLayer.getBounds(), { padding: [10,10] });
      } catch(e){
        map.setView([22.0,82.0], 6);
      }
    }

    async function loadAllStatesAndShowCombined(){
      infoEl.textContent = 'Loading all states...';
      try{
        const promises = Object.entries(files).map(([k,f]) => fetch(f).then(r=>{
          if(!r.ok) throw new Error(`Failed ${f}: ${r.status}`);
          return r.json();
        }).catch(err => {
          console.warn('Fetch failed for', f, err);
          return { type:'FeatureCollection', features: [] };
        }));
        const results = await Promise.all(promises);
        // store per-state filtered data
        let combinedFeatures = [];
        let i = 0;
        for(const key of Object.keys(files)){
          const data = results[i++] || { features: [] };
          const valid = (data.features||[]).filter(validFeature);
          perStateData[key] = { type: 'FeatureCollection', features: valid };
          combinedFeatures = combinedFeatures.concat(valid);
        }
        // show combined on first load
        combinedLayer = L.geoJSON({ type:'FeatureCollection', features: combinedFeatures }, {
          pointToLayer: function(feature, latlng){
            return L.circleMarker(latlng, { radius:3, color:'#145214', fillColor:'#2b8c2b', fillOpacity:0.9 });
          },
          style: function(){ return { color:'#2b8c2b', weight:1, fillOpacity:0.25 }; },
          onEachFeature: function(feature, layer){
            const props = feature.properties || {};
            let title = props.name || props['@id'] || 'Forest';
            layer.bindPopup(title);
          }
        }).addTo(map);

        infoEl.textContent = `Showing all states: ${combinedFeatures.length} valid feature(s).`;
        try { map.fitBounds(combinedLayer.getBounds(), { padding:[10,10] }); } catch(e){ map.setView([22.0,82.0],5); }
      } catch(err){
        console.error(err);
        infoEl.textContent = 'Error loading state files: ' + err.message;
      }
    }

    // New: show combined view (used when dropdown cleared)
    function showCombined(){
      if(currentLayer){ map.removeLayer(currentLayer); currentLayer = null; }
      if(combinedLayer){
        combinedLayer.addTo(map);
        try { map.fitBounds(combinedLayer.getBounds(), { padding:[10,10] }); } catch(e){ map.setView([22.0,82.0],5); }
        infoEl.textContent = `Showing all states: ${combinedLayer.toGeoJSON().features.length} valid feature(s).`;
      } else {
        loadAllStatesAndShowCombined();
      }
    }

    // Modified loadStateGeo to use cached perStateData
    function loadStateGeo(stateKey){
      if(!stateKey){
        showCombined();
        return;
      }
      const data = perStateData[stateKey];
      if(!data){
        // if not loaded yet, fetch single file as fallback
        (async ()=> {
          infoEl.textContent = `Loading ${files[stateKey]} ...`;
          try{
            const res = await fetch(files[stateKey]);
            if(!res.ok) throw new Error(`Failed to fetch ${files[stateKey]}: ${res.status}`);
            const d = await res.json();
            perStateData[stateKey] = { type:'FeatureCollection', features: (d.features||[]).filter(validFeature) };
            renderGeoJSON(perStateData[stateKey]);
          } catch(err){
            console.error(err);
            infoEl.textContent = `Error loading ${files[stateKey]}: ${err.message}`;
          }
        })();
        return;
      }
      renderGeoJSON(data);
    }

    // wire dropdown
    stateSelect.addEventListener('change', function(){
      if(this.value) loadStateGeo(this.value);
      else showCombined();
    });

    // initial load: fetch and show combined view
    loadAllStatesAndShowCombined();

    // ---------- Applications drawn from feature.properties.applications ----------
    // No localStorage; read application entries directly from perStateData features.
    const appsLayerGroup = L.layerGroup().addTo(map);
    let appsVisible = true;

    // Asset layers (water, forest, buildings, bareland)
    const assetLayers = {
      water: L.layerGroup().addTo(map),
      forest: L.layerGroup().addTo(map),
      buildings: L.layerGroup().addTo(map),
      bareland: L.layerGroup().addTo(map)
    };
    let currentAssetCircle = null;
    // Track last fetched counts so we can show in UI
    const lastAssetCounts = { water:0, buildings:0, forest:0, bareland:0 };

    // Colors per asset category
    const assetColors = {
      water: '#1e88e5',
      forest: '#2e7d32',
      buildings: '#6d4c41',
      bareland: '#f6c244'
    };

    function clearAssetLayers(){
      Object.values(assetLayers).forEach(g => { g.clearLayers(); if(map.hasLayer(g)) map.removeLayer(g); });
      if(currentAssetCircle){ map.removeLayer(currentAssetCircle); currentAssetCircle = null; }
      // reset counts UI
      updateCountsUI({ water:0, buildings:0, forest:0, bareland:0 });
    }

    // Build bbox around center (south,west,north,east) for Overpass
    function buildBBox(lat, lon, radiusMeters){
      const km = radiusMeters / 1000;
      const latDelta = km / 111.0; // approx
      const lonDelta = Math.abs(km / (111.320 * Math.cos(lat * Math.PI/180))) || (km/111.0);
      const south = (lat - latDelta).toFixed(6);
      const north = (lat + latDelta).toFixed(6);
      const west = (lon - lonDelta).toFixed(6);
      const east = (lon + lonDelta).toFixed(6);
      return `${south},${west},${north},${east}`;
    }

    // Generic Overpass fetch helper
    async function overpassQuery(query){
      try{
        const url = 'https://overpass-api.de/api/interpreter';
        const body = 'data=' + encodeURIComponent(query);
        const resp = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' }, body });
        if(!resp.ok) throw new Error('Overpass status ' + resp.status);
        return await resp.json();
      } catch(err){
        console.warn('Overpass error', err);
        return null;
      }
    }

    // Create asset marker from element (node or way/relation center)
    function createAssetMarker(elem, category){
      let lat = null, lon = null;
      if(elem.type === 'node'){ lat = elem.lat; lon = elem.lon; }
      else if(elem.center){ lat = elem.center.lat; lon = elem.center.lon; }
      if(lat === null || lon === null) return null;
      const marker = L.circleMarker([lat, lon], { radius:6, color:'#222', weight:0.6, fillColor: assetColors[category], fillOpacity:0.95 });
      const tags = elem.tags || {};
      const title = tags.name || tags.ref || (category.charAt(0).toUpperCase()+category.slice(1));
      let info = `<strong>${escapeHtml(title)}</strong><br/><small>${escapeHtml(JSON.stringify(tags))}</small>`;
      marker.bindPopup(info);
      return marker;
    }

    // Fetch assets around a point (radius meters)
    async function fetchAssetsAround(lat, lon, radiusMeters = 5000){
      clearAssetLayers();
      // draw circle
      currentAssetCircle = L.circle([lat, lon], { radius: radiusMeters, color:'#888', weight:1, dashArray:'4 6', fill:false }).addTo(map);

      const bbox = buildBBox(lat, lon, radiusMeters);
      // queries use out center; include nodes, ways, relations
      const queries = {
        water: ` [out:json][timeout:25]; ( way["natural"="water"](${bbox}); relation["natural"="water"](${bbox}); node["natural"="water"](${bbox}); ); out center; `,
        forest: ` [out:json][timeout:25]; ( way["landuse"="forest"](${bbox}); relation["landuse"="forest"](${bbox}); node["landuse"="forest"](${bbox}); ); out center; `,
        buildings: ` [out:json][timeout:25]; ( way["building"](${bbox}); relation["building"](${bbox}); node["building"](${bbox}); ); out center; `,
        bareland: ` [out:json][timeout:25]; ( way["natural"="bare_rock"](${bbox}); way["landuse"="brownfield"](${bbox}); way["landuse"="grass"](${bbox}); relation["natural"="bare_rock"](${bbox}); relation["landuse"="brownfield"](${bbox}); relation["landuse"="grass"](${bbox}); node["natural"="bare_rock"](${bbox}); node["landuse"="brownfield"](${bbox}); node["landuse"="grass"](${bbox}); ); out center; `
      };

      // Run all queries in parallel (but be mindful of rate limits)
      const cats = Object.keys(queries);
      const results = await Promise.all(cats.map(cat => overpassQuery(queries[cat])));
      // tally counts and add markers
      cats.forEach((cat, idx) => {
        const res = results[idx];
        if(!res || !Array.isArray(res.elements)){
          lastAssetCounts[cat] = 0;
          return;
        }
        const els = res.elements;
        lastAssetCounts[cat] = els.length;
        els.forEach(e => {
          const m = createAssetMarker(e, cat);
          if(m) assetLayers[cat].addLayer(m);
        });
      });

      // Respect the asset filter selection: show only selected category/layers
      applyAssetFilter();

      // Update counts UI after layers are created
      updateCountsUI(lastAssetCounts);
    }

    // Update counts displayed in the floating UI
    function updateCountsUI(counts){
      try{
        document.getElementById('count_water').textContent = 'Water bodies: ' + (counts.water || 0);
        document.getElementById('count_buildings').textContent = 'Buildings: ' + (counts.buildings || 0);
        document.getElementById('count_forest').textContent = 'Forests: ' + (counts.forest || 0);
        document.getElementById('count_bareland').textContent = 'Bare land: ' + (counts.bareland || 0);
      }catch(e){ /* ignore DOM errors */ }
    }

    // Apply the selected asset filter: show/hide asset layers accordingly
    function applyAssetFilter(){
      const sel = document.getElementById('assetFilter');
      const val = sel ? sel.value : 'all';
      // helper to ensure a layer is added or removed
      function ensureLayer(key, show){
        const layer = assetLayers[key];
        if(!layer) return;
        if(show){ if(!map.hasLayer(layer)) map.addLayer(layer); }
        else { if(map.hasLayer(layer)) map.removeLayer(layer); }
      }
      if(val === 'all'){
        ensureLayer('water', true);
        ensureLayer('buildings', true);
        ensureLayer('forest', true);
        ensureLayer('bareland', true);
      } else if(val === 'forest'){
        ensureLayer('forest', true);
        ensureLayer('water', false);
        ensureLayer('buildings', false);
        ensureLayer('bareland', false);
      } else if(val === 'households'){
        // households mapped to buildings layer
        ensureLayer('buildings', true);
        ensureLayer('water', false);
        ensureLayer('forest', false);
        ensureLayer('bareland', false);
      } else if(val === 'water'){
        ensureLayer('water', true);
        ensureLayer('buildings', false);
        ensureLayer('forest', false);
        ensureLayer('bareland', false);
      } else if(val === 'bareland'){
        ensureLayer('bareland', true);
        ensureLayer('water', false);
        ensureLayer('buildings', false);
        ensureLayer('forest', false);
      }
    }

    // Toggle control (reuses existing UI approach)
    const appsToggle = L.control({ position: 'topleft' });
    appsToggle.onAdd = function () {
      const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
      div.style.background = '#fff';
      div.style.padding = '6px';
      div.style.cursor = 'pointer';
      div.title = 'Toggle application markers';
      div.innerHTML = 'Apps';
      div.onclick = () => {
        appsVisible = !appsVisible;
        if (appsVisible) {
          appsLayerGroup.addTo(map);
          div.style.background = '#e6ffe6';
        } else {
          map.removeLayer(appsLayerGroup);
          div.style.background = '#fff';
        }
      };
      return div;
    };
    appsToggle.addTo(map);

    // Asset toggle control
    const assetsToggle = L.control({ position: 'topleft' });
    assetsToggle.onAdd = function () {
      const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
      div.style.background = '#fff';
      div.style.padding = '6px';
      div.style.cursor = 'pointer';
      div.title = 'Toggle nearby assets';
      div.innerHTML = 'Assets';
      div.onclick = () => {
        // toggle visibility
        const anyShown = Object.values(assetLayers).some(g => map.hasLayer(g));
        if(anyShown){
          clearAssetLayers();
          div.style.background = '#fff';
        } else {
          Object.values(assetLayers).forEach(g => g.addTo(map));
          if(currentAssetCircle) currentAssetCircle.addTo(map);
          div.style.background = '#e6ffe6';
        }
      };
      return div;
    };
    assetsToggle.addTo(map);

    // Base layer toggle control (Satellite / OSM)
    const baseToggle = L.control({ position: 'topleft' });
    baseToggle.onAdd = function () {
      const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
      div.style.background = '#fff';
      div.style.padding = '6px';
      div.style.cursor = 'pointer';
      div.title = 'Toggle base map (Satellite / OSM)';
      div.innerHTML = 'Base';
      div.onclick = () => {
        try{
          if(map.hasLayer(tileLayer)){
            map.removeLayer(tileLayer);
            osmLayer.addTo(map);
            div.style.background = '#f0f0f0';
          } else {
            map.removeLayer(osmLayer);
            tileLayer.addTo(map);
            div.style.background = '#e6ffe6';
          }
        }catch(e){/* ignore */}
      };
      return div;
    };
    baseToggle.addTo(map);

    function appColor(status){
      if(status === 'pending') return '#ffd449';
      if(status === 'approved') return '#2b8c2b';
      if(status === 'rejected') return '#d9534f';
      return '#888';
    }

    function escapeHtml(s){
      if(!s) return '';
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    // Collect apps with context so we can persist changes back to the file
    function collectAppsFromFeatures(){
      const apps = [];
      Object.keys(perStateData).forEach(stateKey => {
        const fc = perStateData[stateKey];
        if(!fc || !Array.isArray(fc.features)) return;
        fc.features.forEach(feat => {
          const aList = (feat.properties && Array.isArray(feat.properties.applications)) ? feat.properties.applications : [];
          aList.forEach(a => {
            apps.push(Object.assign({}, a, {
              stateKey: stateKey,
              featureId: feat.id || null,
              coords: (feat.geometry && Array.isArray(feat.geometry.coordinates)) ? feat.geometry.coordinates : null,
              _featureRef: feat
            }));
          });
        });
      });
      return apps;
    }

    // Create a custom SVG DivIcon for a map-pin style marker
    function createAppIcon(status){
      const color = appColor(status || 'pending');
      const svg = `
        <svg width="36" height="48" viewBox="0 0 24 32" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M12 0C7 0 3 4 3 9c0 7.5 9 23 9 23s9-15.5 9-23c0-5-4-9-9-9z" fill="${color}" stroke="#222" stroke-width="0.8"/>
          <circle cx="12" cy="9" r="3.2" fill="#fff" opacity="0.95"/>
        </svg>
      `;
      return L.divIcon({
        className: 'app-icon',
        html: svg,
        iconSize: [36,48],
        iconAnchor: [18,44],
        popupAnchor: [0,-44]
      });
    }

    // Render markers for each application (map-pin icon) with improved popup UI
    function renderApplicationsLayer(){
      appsLayerGroup.clearLayers();
      const apps = collectAppsFromFeatures();
      const visibleApps = filterApps(apps);
      visibleApps.forEach(app => {
        // prefer explicit coords on app else fallback to feature geometry
        let coords = app.coords;
        if(!Array.isArray(coords) && app._featureRef && app._featureRef.geometry){
          coords = app._featureRef.geometry.coordinates;
        }
        if(!Array.isArray(coords) || coords.length < 2) return;
        const latlng = [coords[1], coords[0]];

        const marker = L.marker(latlng, {
          icon: createAppIcon(app.status)
        });

        const statusText = escapeHtml(app.status || 'pending');
        const badgeColor = appColor(app.status || 'pending');

        // DSS recommendations snippet
        let recHtml = '';
        try{
          const recs = app.dss_recommendations || app.dss_recommendations_snapshot || [];
          if(Array.isArray(recs) && recs.length){
            recHtml = '<div class="rec-snippet"><strong>Recommendations</strong>';
            recs.slice(0,3).forEach(r => {
              const name = r.scheme || r[0] || '';
              const score = r.score || r.raw_score || '';
              const url = r.url || '';
              recHtml += `<div class="rec-item">${escapeHtml(name)} <span style="background:#1976d2;color:#fff;padding:3px 6px;border-radius:10px;font-weight:700;margin-left:auto">${escapeHtml(String(score))}</span>`;
              if(url) recHtml += ` <a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">Learn</a>`;
              recHtml += `</div>`;
            });
            recHtml += '</div>';
          }
        } catch(e){ recHtml = ''; }

        const popupHtml = `
          <div class="app-popup">
            <div class="title">
              ${escapeHtml(app.applicant || 'Applicant')}
              <span class="badge" style="background:${badgeColor}">${statusText}</span>
            </div>

            <div><strong>Tribal note</strong></div>
            <div class="tribal-note">${escapeHtml(app.tribal_note || '')}</div>

            <div style="margin-top:8px"><strong>Admin note</strong></div>
            <textarea id="admin_note_${app.id}" placeholder="Enter admin note...">${escapeHtml(app.admin_note || '')}</textarea>

            <div class="buttons">
              <button id="approve_${app.id}" class="btn-approve">Approve</button>
              <button id="reject_${app.id}" class="btn-reject">Reject</button>
            </div>

            <div class="meta">App ID: ${escapeHtml(String(app.id || ''))} · Created: ${escapeHtml(String(app.created_at || '—'))}</div>
            ${recHtml}
          </div>
        `;

        marker.bindPopup(popupHtml, { minWidth: 320, maxWidth: 360 });

        marker.on('popupopen', () => {
          // wire buttons and textarea
          setTimeout(() => {
            const approveBtn = document.getElementById(`approve_${app.id}`);
            const rejectBtn  = document.getElementById(`reject_${app.id}`);
            const ta         = document.getElementById(`admin_note_${app.id}`);
            if(ta) ta.value = app.admin_note || '';
            if(approveBtn) approveBtn.onclick = () => {
              const note = ta ? ta.value : '';
              updateAppStatus(app.stateKey, app.featureId, app.id, 'approved', note);
              marker.closePopup();
            };
            if(rejectBtn) rejectBtn.onclick = () => {
              const note = ta ? ta.value : '';
              updateAppStatus(app.stateKey, app.featureId, app.id, 'rejected', note);
              marker.closePopup();
            };
          }, 20);
        });

        // When marker is clicked (or popup opened), zoom in a bit and fetch assets around it
        marker.on('click', async () => {
          try{
            const latlng = marker.getLatLng();
            // zoom slightly and center
            map.setView(latlng, Math.max(map.getZoom(), 13));
            // fetch assets within 5km
            await fetchAssetsAround(latlng.lat, latlng.lng, 5000);
          } catch(e){ console.warn('Asset fetch failed', e); }
        });

        appsLayerGroup.addLayer(marker);
      });

      if(!appsVisible) map.removeLayer(appsLayerGroup);
    }

    // Persist change by POSTing to Python endpoint (use full origin to avoid 405 on wrong host)
    function persistAppChange(stateKey, featureId, appId, updatedApp){
      const url = 'http://localhost:5000/save_app'; // ensure Flask is running on this host:port
      return fetch(url, {
        method: 'POST',
        mode: 'cors',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ stateKey, featureId, appId, updatedApp })
      }).then(async res => {
        let json = null;
        try { json = await res.json(); } catch(e){ /* no json */ }
        if(!res.ok) {
          const msg = (json && json.message) ? json.message : `HTTP ${res.status}`;
          throw new Error(msg);
        }
        return json;
      });
    }

    // Filtering helpers
    function filterApps(apps){
      const q = (document.getElementById('searchInput')||{}).value || '';
      const status = (document.getElementById('statusFilter')||{}).value || '';
      const scheme = (document.getElementById('schemeFilter')||{}).value || '';
      const minScore = parseInt((document.getElementById('minScore')||{}).value || 0,10) || 0;
      return apps.filter(a => {
        if(status && String((a.status||'').toLowerCase()) !== status.toLowerCase()) return false;
        if(q){ const qq = q.trim().toLowerCase(); if(!(String(a.applicant||'').toLowerCase().includes(qq) || String(a.village||'').toLowerCase().includes(qq))) return false; }
        if(scheme){ const recs = a.dss_recommendations || a.dss_recommendations_snapshot || []; const found = (recs||[]).some(r => (r.scheme || r[0] || '').toLowerCase() === scheme.toLowerCase()); if(!found) return false; }
        if(minScore){ const recs = a.dss_recommendations || a.dss_recommendations_snapshot || []; const high = (recs||[]).some(r => ((r.score||r.raw_score||0) >= minScore)); if(!high) return false; }
        return true;
      });
    }

    // Populate schemeFilter based on known schemes in current data
    function populateSchemeFilter(){
      const set = new Set();
      Object.values(perStateData).forEach(fc => {
        (fc.features||[]).forEach(feat => {
          (feat.properties && feat.properties.applications || []).forEach(a => {
            (a.dss_recommendations || a.dss_recommendations_snapshot || []).forEach(r => {
              const name = r.scheme || r[0] || ''; if(name) set.add(name);
            });
          });
        });
      });
      const sel = document.getElementById('schemeFilter'); if(!sel) return;
      const cur = sel.value || '';
      sel.innerHTML = '<option value="">All schemes</option>' + Array.from(set).map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join('');
      if(cur) sel.value = cur;
    }

    // Export visible applications to CSV
    function exportVisibleAppsToCSV(){
      const apps = collectAppsFromFeatures();
      const visible = filterApps(apps);
      if(!visible.length){ alert('No applications to export'); return; }
      const cols = ['id','applicant','village','stateKey','status','dss_schemes','dss_top_score','admin_note'];
      const rows = visible.map(a => {
        const recs = a.dss_recommendations || a.dss_recommendations_snapshot || [];
        const schemes = (recs||[]).map(r=>r.scheme || r[0] || '').join('|');
        const top = (recs && recs.length) ? (recs[0].score || recs[0].raw_score || '') : '';
        return [a.id||'', a.applicant||'', a.village||'', a.stateKey||'', a.status||'', schemes, top, a.admin_note||''];
      });
      const csv = [cols.join(',')].concat(rows.map(r => r.map(v => '"'+String(v).replace(/"/g,'""')+'"').join(','))).join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'applications_export.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }

    document.getElementById('searchInput').addEventListener('input', () => renderApplicationsLayer());
    document.getElementById('statusFilter').addEventListener('change', () => renderApplicationsLayer());
    document.getElementById('schemeFilter').addEventListener('change', () => renderApplicationsLayer());
    document.getElementById('minScore').addEventListener('input', () => renderApplicationsLayer());
    document.getElementById('exportCsvBtn').addEventListener('click', exportVisibleAppsToCSV);
    // wire asset filter dropdown to apply filter immediately
    const assetFilterEl = document.getElementById('assetFilter');
    if(assetFilterEl){
      assetFilterEl.addEventListener('change', () => {
        applyAssetFilter();
      });
    }

    // repopulate scheme filter after states loaded
    setTimeout(populateSchemeFilter, 800);

    // Update application object inside the feature.properties.applications (in-memory) and persist
    function updateAppStatus(stateKey, featureId, appId, newStatus, adminNote){
      const fc = perStateData[stateKey];
      if(!fc || !Array.isArray(fc.features)) {
        alert('State data not loaded for ' + stateKey);
        return;
      }
      const feat = fc.features.find(f => f.id === featureId);
      if(!feat || !feat.properties) return;
      const apps = Array.isArray(feat.properties.applications) ? feat.properties.applications : [];
      const idx = apps.findIndex(a => a.id === appId);
      if(idx === -1) return;
      // update in-memory
      apps[idx].status = newStatus;
      apps[idx].admin_note = adminNote || '';
      apps[idx].updated_at = new Date().toISOString();
      feat.properties.applications = apps;
      // re-render markers immediately
      renderApplicationsLayer();

      // send persistence request
      persistAppChange(stateKey, featureId, appId, apps[idx])
        .then(resp => {
          if(resp && resp.success){
            console.log('Saved to file:', resp.message || '');
          } else {
            console.error('Save failed', resp);
            alert('Could not save change to file: ' + (resp && resp.message ? resp.message : 'unknown error'));
          }
        })
        .catch(err => {
          console.error('Persist error', err);
          alert('Error saving change to disk: ' + (err && err.message ? err.message : err));
        });
    }

    // Wait for perStateData to be populated by the initial loader, then render apps.
    (function waitThenRenderApps(){
      const t = setInterval(()=>{
        if(Object.keys(perStateData).length > 0){
          renderApplicationsLayer();
          clearInterval(t);
        }
      }, 200);
      // fallback after 5s
      setTimeout(()=>{ renderApplicationsLayer(); clearInterval(t); }, 5000);
    })();
  </script>
</body>
</html>
